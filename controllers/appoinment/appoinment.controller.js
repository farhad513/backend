const authorAppoinmentModel = require("../../models/auth.appoinment.model");
const mongoose = require("mongoose");
const customerAppoinmentModel = require("../../models/customerAppoinment");
const notificationModel = require("../../models/notification.model");
const { responseReturn } = require("../../utiles/response");
const moment = require("moment");
const redis = require("../../utiles/Redis"); // Redis client import
const {
  clearAdminAppointmentsCache,
  clearUserAppointmentsCache,
  clearHospitalAppointmentsCache,
  clearSingleAppointmentCache,
} = require("./appoinmentCache");
const { sendSms } = require("../../utiles/sendSms");
const userModel = require("../../models/userModel");
const hospitalModel = require("../../models/hospital.model");
require("moment/locale/bn"); // ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶≤‡ßã‡¶ï‡ßá‡¶≤ ‡¶≤‡ßã‡¶°

const convertToEnglishNumber = (input) => {
  if (!input) return "";
  const banglaNums = ["‡ß¶", "‡ßß", "‡ß®", "‡ß©", "‡ß™", "‡ß´", "‡ß¨", "‡ß≠", "‡ßÆ", "‡ßØ"];
  const engNums = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
  let output = input;
  banglaNums.forEach((bn, i) => {
    const regex = new RegExp(bn, "g");
    output = output.replace(regex, engNums[i]);
  });
  return output;
};

const placeAppointment = async (req, res) => {
  const {
    userId,
    doctorId,
    hospitalId,
    name,
    phone,
    appointmentDate,
    address,
    age,
    purpose,
  } = req.body;

  try {
    if (!appointmentDate) {
      return res
        .status(400)
        .json({ message: "‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ ‡¶¶‡¶ø‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§" });
    }

    const engDate = convertToEnglishNumber(appointmentDate);
    const [day, month, year] = engDate.split("-");
    if (!day || !month || !year) {
      return res.status(400).json({ message: "‡¶Ö‡¶¨‡ßà‡¶ß ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ‡•§" });
    }

    const parsedDate = new Date(`${year}-${month}-${day}T00:00:00Z`);
    if (isNaN(parsedDate.getTime())) {
      return res.status(400).json({ message: "‡¶Ö‡¶¨‡ßà‡¶ß ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ‡•§" });
    }

    const convertedPhone = convertToEnglishNumber(phone);
    const pending = await customerAppoinmentModel.findOne({
      userId,
      status: "pending",
    });

    if (pending) {
      return res.status(400).json({
        message: "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßÇ‡¶∞‡ßç‡¶¨‡ßá‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶ñ‡¶®‡¶ì pending ‡¶Ü‡¶õ‡ßá‡•§",
      });
    }

    const booking = await customerAppoinmentModel.create({
      userId,
      doctorId,
      hospitalId,
      patientName: name,
      phone: convertedPhone,
      appointmentDate: parsedDate,
      age,
      purpose,
      address,
      status: "pending",
    });

    const authorAppointment = await authorAppoinmentModel.create({
      appoinmentId: booking._id,
      hospitalId,
      doctorId,
      status: "pending",
      address,
      userId,
      date: parsedDate,
    });

    // ‚úÖ Clear old caches
    await clearAdminAppointmentsCache();
    await clearUserAppointmentsCache(userId);
    await clearHospitalAppointmentsCache(hospitalId);
    await clearSingleAppointmentCache(booking._id);

    // ‚úÖ Re-cache (populate doctor & hospital)
    const populated = await authorAppoinmentModel
      .findById(authorAppointment._id)
      .populate("doctorId", "name category")
      .populate("hospitalId", "name");

    // ‚úÖ ‡¶π‡¶æ‡¶∏‡¶™‡¶æ‡¶§‡¶æ‡¶≤‡¶ï‡ßá ‡¶è‡¶∏‡¶è‡¶Æ‡¶è‡¶∏ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã
    const hospital = await hospitalModel.findById(hospitalId);
    const hospitalPhone = hospital?.phone;
    const hospitalName = hospital?.name;
    const doctorInfo = populated?.doctorId;
    const doctorName = doctorInfo?.name;
    const patientName = name;
    if (hospitalPhone) {
      const smsMessage = ` ‡¶®‡¶§‡ßÅ‡¶® ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶¨‡ßÅ‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§
    üë§ ‡¶∞‡ßã‡¶ó‡ßÄ‡¶∞ ‡¶®‡¶æ‡¶Æ: ${patientName} ü©∫ ‡¶ö‡¶ø‡¶ï‡¶ø‡ßé‡¶∏‡¶ï: ${doctorName} 
    üì≤ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶ú‡¶æ‡¶®‡¶§‡ßá ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶π‡¶∏‡¶™‡¶ø‡¶ü‡¶æ‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßá ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§
    ‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶‡•§
    ‚Äî ‡¶Æ‡ßá‡¶°‡¶ø ‡¶´‡¶æ‡¶∏‡ßç‡¶ü ‡¶π‡ßá‡¶≤‡¶• ‡¶ï‡ßá‡ßü‡¶æ‡¶∞`;

      await sendSms(hospitalPhone, smsMessage);
    }

    res.status(201).json({
      message: "‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶¨‡ßÅ‡¶ï ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá",
      appointmentId: booking._id,
    });
  } catch (error) {
    console.log("Place Appointment Error:", error.message);
    res.status(500).json({ message: "‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶¨‡ßÅ‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§" });
  }
};

// ‚úÖ User-wise Appointment List
const get_appoinments = async (req, res) => {
  const { userId, status } = req.params;
  let { page = 1, parPage = 5 } = req.query;
  console.log(status, "status status");
  page = parseInt(page);
  parPage = parseInt(parPage);
  const skipPage = parPage * (page - 1); // ‚úÖ typo fix

  try {
    // ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡¶ø‡¶° ‡¶ï‡¶ø‡¶®‡¶æ ‡¶ö‡ßá‡¶ï
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return responseReturn(res, 400, { message: "‡¶Ö‡¶¨‡ßà‡¶ß ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø‡•§" });
    }

    // ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∂ ‡¶ï‡ßÄ ‡¶§‡ßà‡¶∞‡¶ø
    const cacheKey = `user:${userId}:appointments:${
      status || "all"
    }:page${page}`;

    // ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∂‡¶° ‡¶°‡ßá‡¶ü‡¶æ ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶∏‡ßá‡¶ü‡¶æ ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶®
    const cached = await redis.get(cacheKey);
    if (cached) {
      return responseReturn(res, 200, JSON.parse(cached));
    }

    // ‡¶°‡¶æ‡¶á‡¶®‡¶æ‡¶Æ‡¶ø‡¶ï ‡¶ï‡ßÅ‡ßü‡ßá‡¶∞‡¶ø ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™
    const query = { userId: new mongoose.Types.ObjectId(userId) };
    if (status && status !== "all") {
      query.status = status;
    }

    // ‡¶ü‡ßã‡¶ü‡¶æ‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü
    const totalAppointments = await customerAppoinmentModel.countDocuments(
      query
    );

    // ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü ‡¶´‡ßá‡¶ö
    const appointments = await customerAppoinmentModel
      .find(query)
      .populate("doctorId", "name image category")
      .skip(skipPage)
      .sort({ createdAt: -1 })
      .limit(parPage);

    // ‡¶´‡¶æ‡¶á‡¶®‡¶æ‡¶≤ ‡¶∞‡ßá‡¶ú‡¶æ‡¶≤‡ßç‡¶ü
    const result = {
      message: "‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶≤‡ßã‡¶° ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§",
      appointments,
      totalAppointments,
    };

    // ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∂ ‡¶∏‡ßá‡¶ü (‡ßß‡ß´ ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü)
    await redis.setex(cacheKey, 900, JSON.stringify(result));

    // ‡¶∞‡ßá‡¶∏‡¶™‡¶®‡ßç‡¶∏ ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶®
    responseReturn(res, 200, result);
  } catch (error) {
    console.log("Appointment API Error:", error);
    responseReturn(res, 500, { message: "‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø‡•§" });
  }
};

// ‚úÖ Admin Appointment List
const get_admin_appoinments = async (req, res) => {
  let { page = 1, parPage = 5, searchValue } = req.query;
  page = parseInt(page);
  parPage = parseInt(parPage);
  const skipPage = parPage * (page - 1);

  try {
    const cacheKey = `admin:appointments:page${page}:search:${
      searchValue || "none"
    }`;
    const cached = await redis.get(cacheKey);
    if (cached) {
      return responseReturn(res, 200, JSON.parse(cached));
    }

    let query = {};
    if (searchValue) {
      if (/^[0-9a-fA-F]{24}$/.test(searchValue)) {
        // ObjectId ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá
        query = { _id: searchValue };
      } else if (/^01[0-9]{9}$/.test(searchValue)) {
        // ‡¶´‡ßã‡¶® ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá
        query = { phone: searchValue };
      } else {
        // ‡¶®‡¶æ‡¶Æ ‡¶¶‡¶ø‡ßü‡ßá ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö
        query = { patientName: { $regex: searchValue, $options: "i" } };
      }
    }

    const appointments = await customerAppoinmentModel
      .find(query)
      .skip(skipPage)
      .limit(parPage)
      .sort({ createdAt: -1 })
      .populate("doctorId", "name category")
      .populate("hospitalId", "name")
      .populate("userId", "name phone");
    const totalAppointments = await customerAppoinmentModel.countDocuments(
      query
    );

    const result = { appointments, totalAppointments };
    await redis.setex(cacheKey, 900, JSON.stringify(result));

    responseReturn(res, 200, result);
  } catch (error) {
    console.log(error);
    responseReturn(res, 500, { message: "server error" });
  }
};

const engToBnNumber = (number) => {
  return number.toString().replace(/[0-9]/g, (digit) => "‡ß¶‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ"[digit]);
};

const hospital_appoinment_status_update = async (req, res) => {
  const { appoinmentId } = req.params;
  const { status, appointmentDate, serial, time } = req.body;

  try {
    const author = await authorAppoinmentModel.findById(appoinmentId);
    if (!author)
      return responseReturn(res, 404, { message: "‡¶°‡¶æ‡¶ü‡¶æ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§" });

    const customer = await customerAppoinmentModel
      .findById(author.appoinmentId)
      .populate("doctorId");
    console.log(customer)
    if (!customer)
      return responseReturn(res, 404, { message: "‡¶°‡¶æ‡¶ü‡¶æ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§" });

    // ‚úÖ ‡¶Ø‡¶¶‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶π‡ßü, ‡¶Ü‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ
    if (customer.isComplete) {
      return responseReturn(res, 400, {
        message: "‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶á‡¶§‡ßã‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶π‡ßü‡ßá‡¶õ‡ßá, ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ‡•§",
      });
    }

    const isComplete = status === "confirmed";

    // ‚úÖ ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
    await authorAppoinmentModel.findByIdAndUpdate(appoinmentId, {
      status,
      appointmentDate,
      serial,
      isComplete,
      time,
    });

    await customerAppoinmentModel.findByIdAndUpdate(author.appoinmentId, {
      status,
      appointmentDate,
      serial,
      isComplete,
      time,
    });

    // ‚úÖ Cache Clear
    await clearAdminAppointmentsCache();
    await clearUserAppointmentsCache(author.userId);
    await clearHospitalAppointmentsCache(author.hospitalId);
    await clearSingleAppointmentCache(appoinmentId);

    // ‚úÖ SMS ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§‡¶ø
    const userPhone = customer.phone;
    const userName = customer.patientName;
    const doctorName = customer.doctorId?.name || "";
    const formattedAppointmentDate = author?.date
      ? moment(author.date).locale("bn").format("D MMMM, YYYY")
      : "";

    const enToBnNumber = (number) => {
      const bnDigits = ["‡ß¶", "‡ßß", "‡ß®", "‡ß©", "‡ß™", "‡ß´", "‡ß¨", "‡ß≠", "‡ßÆ", "‡ßØ"];
      return number
        .toString()
        .split("")
        .map((d) => (/\d/.test(d) ? bnDigits[d] : d))
        .join("");
    };

    const getBanglaTimePeriod = (hour) => {
      if (hour >= 4 && hour < 12) return "‡¶∏‡¶ï‡¶æ‡¶≤";
      else if (hour >= 12 && hour < 15) return "‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞";
      else if (hour >= 15 && hour < 17) return "‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤";
      else if (hour >= 17 && hour < 19) return "‡¶∏‡¶®‡ßç‡¶ß‡ßç‡¶Ø‡¶æ";
      else return "‡¶∞‡¶æ‡¶§";
    };

    const banglaSerial = serial ? enToBnNumber(serial) : "";

    let smsMessage = "";

    if (status === "confirmed") {
      // ‚úÖ time ‡¶Ø‡¶¶‡¶ø ISO string ‡¶Ü‡¶∏‡ßá (UTC)
      const dateObj = new Date(time); // UTC
      let localHour = dateObj.getUTCHours() + 6; // BST +6
      let localMinute = dateObj.getUTCMinutes();

      if (localHour >= 24) localHour -= 24; // next day adjustment

      const hour12 = localHour % 12 === 0 ? 12 : localHour % 12;
      const timePeriod = getBanglaTimePeriod(localHour);

      const formattedTime = `${enToBnNumber(hour12)}:${enToBnNumber(
        localMinute.toString().padStart(2, "0")
      )} ${timePeriod}`;

      smsMessage = `‡¶™‡ßç‡¶∞‡¶ø‡ßü ${userName}, ‡¶Ö‡¶≠‡¶ø‡¶®‡¶®‡ßç‡¶¶‡¶®! ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü ${doctorName} ‡¶è‡¶∞ ‡¶∏‡¶ô‡ßç‡¶ó‡ßá ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§\n‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ: ${formattedAppointmentDate} ‡¶∏‡¶Æ‡ßü: ${formattedTime}${
        banglaSerial ? `\n‡¶∏‡¶ø‡¶∞‡¶ø‡ßü‡¶æ‡¶≤ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞: ${banglaSerial}` : ""
      }\n- ‡¶Æ‡ßá‡¶°‡¶ø ‡¶´‡¶æ‡¶∏‡ßç‡¶ü ‡¶π‡ßá‡¶≤‡¶• ‡¶ï‡ßá‡ßü‡¶æ‡¶∞`;
    } else if (status === "cancelled") {
      smsMessage = `‡¶™‡ßç‡¶∞‡¶ø‡ßü ${userName}, ‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§! ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡¶ü‡¶ø ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§\n‡¶°‡¶æ‡¶ï‡ßç‡¶§‡¶æ‡¶∞: ${doctorName}\n‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ: ${formattedAppointmentDate}\n\n- ‡¶Æ‡ßá‡¶°‡¶ø ‡¶´‡¶æ‡¶∏‡ßç‡¶ü ‡¶π‡ßá‡¶≤‡¶• ‡¶ï‡ßá‡ßü‡¶æ‡¶∞`;
    }

    // ‚úÖ SMS ‡¶™‡¶æ‡¶†‡¶æ‡¶ì
    if (userPhone) {
      await sendSms(userPhone, smsMessage);
    }

    return responseReturn(res, 200, {
      message: "‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç SMS ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§",
    });
  } catch (error) {
    console.log(error);
    return responseReturn(res, 500, { message: "server error" });
  }
};


const get_hospital_appoinments = async (req, res) => {
  const { hospitalId } = req.params;
  let { page = 1, parPage = 10, searchValue = "" } = req.query;

  page = parseInt(page);
  parPage = parseInt(parPage);
  const skipPage = parPage * (page - 1);

  try {
    const cacheKey = `hospital:${hospitalId}:appointments:page${page}:search:${searchValue}`;
    const cached = await redis.get(cacheKey);
    if (cached) {
      return responseReturn(res, 200, JSON.parse(cached));
    }

    const matchStage = {
      hospitalId: new mongoose.Types.ObjectId(hospitalId),
    };

    const pipeline = [
      { $match: matchStage },
      {
        $lookup: {
          from: "appoinments",
          localField: "appoinmentId",
          foreignField: "_id",
          as: "appoinment",
        },
      },
      { $unwind: "$appoinment" },
      {
        $lookup: {
          from: "doctors",
          localField: "doctorId",
          foreignField: "_id",
          as: "doctor",
        },
      },
      { $unwind: { path: "$doctor", preserveNullAndEmptyArrays: true } },
    ];

    if (searchValue) {
      if (searchValue.match(/^[0-9a-fA-F]{24}$/)) {
        pipeline.push({
          $match: { _id: new mongoose.Types.ObjectId(searchValue) },
        });
      } else {
        pipeline.push({
          $match: {
            "appoinment.patientName": { $regex: searchValue, $options: "i" },
          },
        });
      }
    }

    pipeline.push(
      { $sort: { createdAt: -1 } },
      { $skip: skipPage },
      { $limit: parPage },
      {
        $project: {
          _id: 1,
          createdAt: 1,
          "appoinment.patientName": 1,
          "appoinment.category": 1,
          "appoinment.appointmentDate": 1,
          "appoinment.serial": 1,
          status: 1,
          "doctor.name": 1,
          "doctor.category": 1,
          isComplete: 1,
        },
      }
    );

    const appoinments = await authorAppoinmentModel.aggregate(pipeline);

    // total count
    const countPipeline = [
      { $match: matchStage },
      {
        $lookup: {
          from: "appoinments",
          localField: "appoinmentId",
          foreignField: "_id",
          as: "appoinment",
        },
      },
      { $unwind: "$appoinment" },
    ];

    if (searchValue) {
      if (searchValue.match(/^[0-9a-fA-F]{24}$/)) {
        countPipeline.push({
          $match: { _id: new mongoose.Types.ObjectId(searchValue) },
        });
      } else {
        countPipeline.push({
          $match: {
            "appoinment.patientName": { $regex: searchValue, $options: "i" },
          },
        });
      }
    }

    countPipeline.push({ $count: "total" });

    const totalResult = await authorAppoinmentModel.aggregate(countPipeline);
    const totalAppoinments = totalResult[0]?.total || 0;

    const result = { appoinments, totalAppoinments };
    console.log(appoinments);
    // await redis.setex(cacheKey, 900, JSON.stringify(result)); // 15 min cache
    console.log(totalAppoinments);
    responseReturn(res, 200, result);
  } catch (error) {
    console.log(error);
    responseReturn(res, 500, { message: "server error" });
  }
};
const get_hospital_appoinment = async (req, res) => {
  const { appoinmentId } = req.params;
  try {
    const cacheKey = `hospital:appointment:${appoinmentId}`;
    const cached = await redis.get(cacheKey);
    if (cached) {
      return responseReturn(res, 200, JSON.parse(cached));
    }

    const appoinment = await authorAppoinmentModel
      .findById(appoinmentId)
      .populate("appoinmentId", "patientName appointmentDate serial ")
      .populate("doctorId", "name category")
      .populate("hospitalId", "name");

    if (!appoinment) {
      return responseReturn(res, 404, { message: "‡¶°‡¶æ‡¶ü‡¶æ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§" });
    }

    // await redis.setex(cacheKey, 900, JSON.stringify({ appoinment })); // cache 15 min
    responseReturn(res, 200, { appoinment });
  } catch (error) {
    console.log(error);
    responseReturn(res, 500, { message: "server error" });
  }
};

module.exports = {
  placeAppointment,
  get_appoinments,
  get_admin_appoinments,
  hospital_appoinment_status_update,
  get_hospital_appoinments,
  get_hospital_appoinment,
};
